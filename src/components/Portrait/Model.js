// Personal website and portfolio //
// 2022                           //
// Built by Mark Lisanti          //
// https://github.com/marklasagne //

// GLTF model Auto-generated by: https://github.com/pmndrs/gltfjsx

import React, { useRef, useEffect, useState } from 'react';
import { useFrame, useThree, extend } from '@react-three/fiber';
import { useGLTF, shaderMaterial } from '@react-three/drei';
import glsl from 'babel-plugin-glsl/macro';

export default function Model({ ...props }) {
  const [scrollY, setScrollY] = useState(0);

  const { viewport } = useThree();
  const { nodes, materials } = useGLTF('/portrait.glb');
  
  const group = useRef();
  const eyes = useRef();
  let x_middle = viewport.width / 2;
  let y_middle = viewport.height / 2;

  useGLTF.preload('/portrait.glb');

  useEffect(() => {
    const handleScroll = () => {
      setScrollY(window.scrollY);
    };
    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, []);

  const Distort = () => {
    return (
      <mesh geometry={nodes.Head.geometry}>
      <shaderMaterial
        uniforms={{
          uOriginalTexture: { value: materials.Head_texture.map },
          uScrollY: { value: scrollY }
        }}
        vertexShader={DistortShaderMaterial.vertexShader}
        fragmentShader={DistortShaderMaterial.fragmentShader}
      />
      <mesh geometry={nodes.Eyebrow_lashes.geometry} material={materials['Material.001']} />
      <mesh geometry={nodes.Mustache.geometry} material={materials.Material} />
    </mesh>
    );
  };
  
  extend({ DistortShaderMaterial });

  useFrame(({ mouse }) => {
    const group_rotation_x = group.current.rotation.x;
    const group_rotation_y = group.current.rotation.y;
    if (mouse.x > -0.75 && mouse.x < 0.75 && mouse.y > -0.75 && mouse.y < 0.75) {
      const x = (mouse.x * x_middle) / 30;
      const y = (mouse.y * y_middle) / 30;
      group.current.rotation.set(-y, x, 0);
      eyes.current.rotation.set(-y / 4, x / 4, 0);
    } else {
      const step = 0.00001 * 500;
      const stepEyes = 0.00001 * 100;
      group.current.rotation.x = Math.abs(group_rotation_x) / 10 < 0.001 ? 0 : group.current.rotation.x > 0 ? group.current.rotation.x - step : group.current.rotation.x + step;
      eyes.current.rotation.x = Math.abs(group_rotation_x) / 10 < 0.001 ? 0 : eyes.current.rotation.x > 0 ? eyes.current.rotation.x - stepEyes : eyes.current.rotation.x + stepEyes;
      group.current.rotation.y = Math.abs(group_rotation_y) / 10 < 0.001 ? 0 : group.current.rotation.y > 0 ? group.current.rotation.y - step : group.current.rotation.y + step;
      eyes.current.rotation.y = Math.abs(group_rotation_y) / 10 < 0.001 ? 0 : eyes.current.rotation.y > 0 ? eyes.current.rotation.y - stepEyes : eyes.current.rotation.y + stepEyes;
    }
  });

  return (
    <>
      <group receiveShadow ref={group} {...props} dispose={null}>
        <mesh geometry={nodes.Beanie.geometry} material={materials.Beanie_texture} position={[0, 1.013, -0.113]} rotation={[1.565, 0, 0]} scale={[0.795, 0.739, 0.741]} />
        <group ref={eyes}>
          <mesh geometry={nodes.Left_eye.geometry} material={materials.Left_eye_texture} position={[0.302, 0.355, 0.89]} rotation={[1.666, 0.513, -0.189]} scale={[0.255, 0.301, 0.249]} />
          <mesh geometry={nodes.Right_eye.geometry} material={materials.Right_eye_texture} position={[-0.287, 0.353, 0.892]} rotation={[1.603, 0.5, 0.159]} scale={[0.255, 0.301, 0.249]} />
        </group>
        <mesh geometry={nodes.Nose_ring.geometry} position={[-0.004, -0.071, 1.227]} rotation={[1.564, 0, 0.019]} scale={0.056}>

        </mesh>
        <Distort />
      </group>
    </>
  )
}

const DistortShaderMaterial = shaderMaterial(
  // Uniform
  {
    uTime: { value: 0.0 },
    uOriginalTexture: { value: null },
    uScrollY: { value: 0.0 },
  },
  // Vertex
  glsl`
    precision mediump float;
    varying vec2 vUv;
    varying vec3 vNormal; // Declare vNormal
    #pragma glslify: snoise3 = require(glsl-noise/simplex/3d);
    uniform float uScrollY; 
  
    void main() {
      vUv = uv;
  
      vec3 pos = position;
      float noiseFreq = 10.0;
      float noiseAmp = uScrollY * 0.01;
  
      float distortionFactor = 1.0 - smoothstep(0.0, 1.0, pos.y);
      pos.y += snoise3(vec3(pos.x * noiseFreq, pos.y, pos.z)) * noiseAmp * distortionFactor;
  
      // Calculate the normal by perturbing the position slightly
      vec3 pos1 = pos + vec3(0.01, 0.0, 0.0); // Perturb in the X direction
      vec3 pos2 = pos + vec3(0.0, 0.01, 0.0); // Perturb in the Y direction
      vec3 normal = normalize(cross(pos1 - pos, pos2 - pos));
  
      vNormal = normal; // Pass the normal to the fragment shader
  
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `   ,
  // Fragment
  glsl`
      precision mediump float;
      varying vec2 vUv;
      varying vec3 vNormal; // Declare vNormal (must match the vertex shader)
    
      uniform sampler2D uOriginalTexture; 

      void main() {
        vec3 originalColor = texture2D(uOriginalTexture, vUv).xyz;
        gl_FragColor = vec4(originalColor, 1.0);
      }
  `,
);

useGLTF.preload('/portrait.glb');




// <mesh geometry={nodes.Head.geometry} material={materials.Head_texture}>


