// Personal website and portfolio //
// 2022                           //
// Built by Mark Lisanti          //
// https://github.com/marklasagne //

// GLTF model Auto-generated by: https://github.com/pmndrs/gltfjsx

import React, { useRef } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { useGLTF, } from '@react-three/drei';


const sumValues = (obj) => {
  return Object.values(obj).reduce((a,b) => a + b, 0)
}

export default function Model({ ...props }) {
  const { viewport } = useThree();
  const { nodes, materials } = useGLTF('/portrait.gltf');
  const group = useRef();
  const eyes = useRef();
  let x_middle = viewport.width / 2;
  let y_middle = viewport.height / 2;


  useFrame(({ mouse }) => {
      if (mouse.x > -0.75 && mouse.x < 0.75 && mouse.y > -0.75 && mouse.y < 0.75 ) {
        //console.log('mouse entered')
        const x = (mouse.x * x_middle) / 30;
        const y = (mouse.y * y_middle) / 30;
        group.current.rotation.set(-y, x, 0);
        eyes.current.rotation.set(-y / 4, x / 4, 0);
      } else {
        //console.log('mouse exit')
    
        let rotation = eyes.current.rotation;
        let rotation_x = eyes.current.rotation.x;
   
        let test = Math.round((rotation_x * 10000) / 10000)

        if (rotation_x != 0) {
          if (test > 0) {
            eyes.current.rotation.set(rotation_x - 0.0001)
            console.log(eyes.current.rotation.x);
          } else {
            eyes.current.rotation.set(rotation_x + 0.0001)
            console.log(eyes.current.rotation.x);
          }
        }

  

      
        // const sliced = Object.keys(rotation).slice(0, 3).reduce((result, key) => {
        //  result[key] = rotation[key];
        //  return result;
        // }, {});

        // console.log(sum)
        // console.log(Math.round(sum * 10000) / 10000)
        
        //-0.016462903711422838 
      
        //-0.0165
        //group.current.rotation.set.x(0, 0, 0);
        //eyes.current.rotation.set(0, 0, 0);
      

      }
  })



  // while (Math.floor(kernelArray[0]) === 0)
  //const sumValues = obj => Object.values(obj).reduce((a, b) => a + b, 0);

  return (
    <group receiveShadow ref={group} {...props} dispose={null} position={[1.25, 0, 0]}>
      <mesh 
        geometry={nodes.beanie_low_RetopoFlow017.geometry}
        material={materials['Material.002']}
        position={[0, 0.94, -0.15]}
        rotation={[1.45, 0, 0]}
        scale={[0.77, 0.74, 0.83]}
      />
      <group ref={eyes}>
        <mesh 
          geometry={nodes.uploads_files_172137_eye.geometry}
          material={materials['Default OBJ']}
          position={[0.3, 0.35, 0.89]}
          rotation={[1.68, 0.51, -0.23]}
          scale={[0.26, 0.3, 0.25]}
        />
        <mesh 
          geometry={nodes.uploads_files_172137_eye001.geometry}
          material={materials['Default OBJ.004']}
          position={[-0.28, 0.36, 0.89]}
          rotation={[1.44, 0.51, 0.27]}
          scale={[0.26, 0.3, 0.25]}
        />
      </group>
      <mesh geometry={nodes.FaceBuilderHead.geometry} material={materials.FaceTexture} />
      <mesh geometry={nodes.Mesh.geometry} material={materials.Mustache} />
      <mesh 
        geometry={nodes.Torus.geometry}
        material={materials['Material.005']}I
        position={[0, -0.07, 1.23]}
        rotation={[1.56, 0, 0.02]}
        scale={[0.06, 0.06, 0.06]}
      />
    </group>
  )
}

useGLTF.preload('/portrait.gltf')
