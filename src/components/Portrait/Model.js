// Personal website and portfolio //
// 2022                           //
// Built by Mark Lisanti          //
// https://github.com/marklasagne //

// GLTF model Auto-generated by: https://github.com/pmndrs/gltfjsx

import React, { useRef, useEffect, useState } from 'react';
import { useFrame, useThree, extend, MultiMaterial } from '@react-three/fiber';
import { useGLTF, shaderMaterial } from '@react-three/drei';
import glsl from 'babel-plugin-glsl/macro';

export default function Model({ ...props }) {
  const [scrollY, setScrollY] = useState(0);

  const { viewport } = useThree();
  const { nodes, materials } = useGLTF('/portrait.glb');
  const group = useRef();
  const eyes = useRef();
  let x_middle = viewport.width / 2;
  let y_middle = viewport.height / 2;

  useGLTF.preload('/portrait.glb');

  useEffect(() => {
    const handleScroll = () => {
      setScrollY(window.scrollY);
    };
    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, []);

  const DistortShaderMaterial = shaderMaterial(
    // Uniform
    {
      uTime: { value: 0.0 },
      uOriginalTexture: { value: null },
      uScrollY: { value: materials.Head_texture.map  }, 
    },
    // Vertex
    glsl`
      precision mediump float;
      varying vec2 vUv;
      #pragma glslify: snoise3 = require(glsl-noise/simplex/3d);
      uniform float uScrollY; 

      void main() {
        vUv = uv;

        vec3 pos = position;
        float noiseFreq = 10.0;
        float noiseAmp = uScrollY * 0.01;

        float distortionFactor = 1.0 - smoothstep(0.0, 1.0, pos.y);
        pos.y += snoise3(vec3(pos.x * noiseFreq, pos.y, pos.z)) * noiseAmp * distortionFactor;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
`   ,
    // Fragment
    glsl`
      precision mediump float;
      varying vec2 vUv;
      uniform sampler2D uOriginalTexture; 

      void main() {
        vec3 originalColor = texture2D(uOriginalTexture, vUv).xyz;
        vec3 finalColor = originalColor * vec3(0.8); 
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `,
  );

  const Distort = () => {
    return (
      <mesh geometry={nodes.Head.geometry} material={materials.Head_texture}>
        <distortShaderMaterial uniforms-uOriginalTexture-value={materials.Head_texture.map} uniforms-uScrollY-value={scrollY} />
        <mesh geometry={nodes.Eyebrow_lashes.geometry} material={materials['Material.001']} />
        <mesh geometry={nodes.Mustache.geometry} material={materials.Material} />
      </mesh>
    )
  }
  extend({ DistortShaderMaterial });

  useFrame(({ mouse }) => {
    const group_rotation_x = group.current.rotation.x;
    const group_rotation_y = group.current.rotation.y;
    if (mouse.x > -0.75 && mouse.x < 0.75 && mouse.y > -0.75 && mouse.y < 0.75) {
      const x = (mouse.x * x_middle) / 30;
      const y = (mouse.y * y_middle) / 30;
      group.current.rotation.set(-y, x, 0);
      eyes.current.rotation.set(-y / 4, x / 4, 0);
    } else {
      const step = 0.00001 * 500;
      const stepEyes = 0.00001 * 100;
      group.current.rotation.x = Math.abs(group_rotation_x) / 10 < 0.001 ? 0 : group.current.rotation.x > 0 ? group.current.rotation.x - step : group.current.rotation.x + step;
      eyes.current.rotation.x = Math.abs(group_rotation_x) / 10 < 0.001 ? 0 : eyes.current.rotation.x > 0 ? eyes.current.rotation.x - stepEyes : eyes.current.rotation.x + stepEyes;
      group.current.rotation.y = Math.abs(group_rotation_y) / 10 < 0.001 ? 0 : group.current.rotation.y > 0 ? group.current.rotation.y - step : group.current.rotation.y + step;
      eyes.current.rotation.y = Math.abs(group_rotation_y) / 10 < 0.001 ? 0 : eyes.current.rotation.y > 0 ? eyes.current.rotation.y - stepEyes : eyes.current.rotation.y + stepEyes;
    }
  });

  const KeyLight = ({ brightness, color, scrollX }) => {
  const keyLightRef = useRef();

  useEffect(() => {
    keyLightRef.current.position.set(-3, 0, 5);
  }, []);

  useFrame(() => {
    // Update the X position of the light based on the scrollX value
    keyLightRef.current.position.x = -3 + scrollX * 0.005; // Adjust the factor as needed
  });

  return (
    <rectAreaLight
      width={3}
      height={3}
      color={color}
      intensity={brightness}
      ref={keyLightRef}
      lookAt={[0, 0, 0]}
      penumbra={1}
      castShadow
    />
  );
}

  return (
    <>
      <KeyLight brightness={8} color={"#fbede2"} scrollX={scrollX} />
    <group receiveShadow ref={group} {...props} dispose={null}>
      <mesh geometry={nodes.Beanie.geometry} material={materials.Beanie_texture} position={[0, 1.013, -0.113]} rotation={[1.565, 0, 0]} scale={[0.795, 0.739, 0.741]} />
      <group ref={eyes}>
        <mesh geometry={nodes.Left_eye.geometry} material={materials.Left_eye_texture} position={[0.302, 0.355, 0.89]} rotation={[1.666, 0.513, -0.189]} scale={[0.255, 0.301, 0.249]} />
        <mesh geometry={nodes.Right_eye.geometry} material={materials.Right_eye_texture} position={[-0.287, 0.353, 0.892]} rotation={[1.603, 0.5, 0.159]} scale={[0.255, 0.301, 0.249]} />
      </group>
      <mesh geometry={nodes.Nose_ring.geometry} position={[-0.004, -0.071, 1.227]} rotation={[1.564, 0, 0.019]} scale={0.056}>
        <meshStandardMaterial attach="material" color='silver'></meshStandardMaterial>
      </mesh>
      <Distort />
    </group>
    </>
  )
}

useGLTF.preload('/portrait.glb');




// <mesh geometry={nodes.Head.geometry} material={materials.Head_texture}>


