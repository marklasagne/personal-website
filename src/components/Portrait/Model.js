// Personal website and portfolio //
// 2022                           //
// Built by Mark Lisanti          //
// https://github.com/marklasagne //

// GLTF model Auto-generated by: https://github.com/pmndrs/gltfjsx

import React, { useRef } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { useGLTF, } from '@react-three/drei';


const sumValues = (obj) => {
  return Object.values(obj).reduce((a, b) => a + b, 0)
}

export default function Model({ ...props }) {
  const { viewport } = useThree();
  const { nodes, materials } = useGLTF('/portrait.glb');
  const group = useRef();
  const eyes = useRef();
  let x_middle = viewport.width / 2;
  let y_middle = viewport.height / 2;

  useGLTF.preload('/portrait.glb');

  /*
0.009111083391207324 2 Model.js:32
0.009522883770470928 Model.js:32
0.009934684149734535 Model.js:32
0.011993686046052578 Model.js:32
0.014876288700897832 Model.js:32
0.0185824921142703 Model.js:32
0.021876895148379174 Model.js:32
0.02640669932027885 Model.js:32
0.030524703112914938

  */


  useFrame(({ mouse }) => {

    let group_rotation_x = group.current.rotation.x;
    let group_rotation_y = group.current.rotation.y;

    if (mouse.x > -0.75 && mouse.x < 0.75 && mouse.y > -0.75 && mouse.y < 0.75) {
      //console.log('mouse entered')
      const x = (mouse.x * x_middle) / 30;
      const y = (mouse.y * y_middle) / 30;


      group.current.rotation.set(-y, x, 0);
      eyes.current.rotation.set(-y / 4, x / 4, 0);
    } else {

      // x
      if (group_rotation_x != 0) {
        if ((Math.abs(group_rotation_x) / 10) < 0.001) {
          group.current.rotation.x = 0;
          eyes.current.rotation.x = 0;
        }
        if (group.current.rotation.x > 0) {
          group.current.rotation.x -= 0.00001 * 500;
          eyes.current.rotation.x -= 0.00001 * 100;
        } else {
          group.current.rotation.x += 0.00001 * 500;
          eyes.current.rotation.x += 0.00001 * 100;
        }
      }

      // y
      if (group_rotation_y != 0) {
        if ((Math.abs(group_rotation_y) / 10) < 0.001) {
          group.current.rotation.y = 0;
          eyes.current.rotation.y = 0;
        }
        if (group.current.rotation.y > 0) {
          group.current.rotation.y -= 0.00001 * 500;
          eyes.current.rotation.y -= 0.00001 * 100;
        } else {
          group.current.rotation.y += 0.00001 * 500;
          eyes.current.rotation.y += 0.00001 * 100;
        }
      }
    }
  })




  // while (Math.floor(kernelArray[0]) === 0)
  //const sumValues = obj => Object.values(obj).reduce((a, b) => a + b, 0);


  return (
    <group receiveShadow ref={group} {...props} dispose={null}>
      <mesh geometry={nodes.Beanie.geometry} material={materials.Beanie_texture} position={[0, 1.013, -0.113]} rotation={[1.565, 0, 0]} scale={[0.795, 0.739, 0.741]} />
      <group ref={eyes}>
        <mesh geometry={nodes.Left_eye.geometry} material={materials.Left_eye_texture} position={[0.302, 0.355, 0.89]} rotation={[1.666, 0.513, -0.189]} scale={[0.255, 0.301, 0.249]} />
        <mesh geometry={nodes.Right_eye.geometry} material={materials.Right_eye_texture} position={[-0.285, 0.353, 0.888]} rotation={[1.474, 0.513, 0.197]} scale={[0.255, 0.301, 0.249]} />
      </group>
      <mesh geometry={nodes.Nose_ring.geometry} material={materials.Nose_ring_texture} position={[-0.004, -0.071, 1.227]} rotation={[1.564, 0, 0.019]} scale={0.056} />
      <mesh geometry={nodes.Head.geometry} material={materials.Head_texture}>
        <mesh geometry={nodes.Curves.geometry} material={materials.Material} />
      </mesh>
    </group>
  )
}

useGLTF.preload('/portrait.glb');







